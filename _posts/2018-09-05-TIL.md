---
title: '[TIL - 0905] JVM 힙 영역과 가비지 컬렉터 조금 더 알아가기'
author: imjinbro
date: 2018-09-06 00:6
tags: [TIL, jvm, gc]
comments: true
sitemap :
  changefreq : daily
  priority : 1.0
---

## Jvm 메모리 힙 영역
* 힙 : 객체가 저장되는 곳, 쓰레드 간 공유 영역, gc의 청소 대상 - 참조되지않는 객체(메모리 회수)
* 추상적인 가비지 컬렉터 지식을 조금 더 구체화 하고 싶었음
  
### 가비지 컬렉터 조금 더 알아가기
* GC가 청소할 때는 'stop-the-world'로 자바 어플리케이션의 동작을 일시적으로 멈추고 청소함 : 청소 작업 쓰레드 이외의 쓰레드는 동작 멈춤
* GC 성능 튜닝 : 'stop-the-world' 시간 줄이는 것에 집중, 어플리케이션 처리 일시정지가 길어지는만큼 처리 속도가 느리게 보임
* 메모리 청소 시에 부분 부분 청소를 해서 메모리를 파편화 시켜버리면 사용하기 좋지 않음 : 같은 여유 공간인데 연속적인 공간인 것과 파편화되어있는 것의 차이는 파편화 되어 있으면 애매한 크기일 때 할당할 수 없는 공간이 되어버림
  
### 힙 영역과 가비지 컬렉터
* 힙 영역은 크게 2가지로 나눔 : HotSpot VM(오라클의 JVM) 기준 효율적인 청소(stop-the-world 시간을 줄이는)를 하기위해 영역을 나눔
  1. young : 최근에 생성된 객체는 여기에 저장, 청소 작업을 minor gc라고 함, 컬렉터마다 동일한 방식으로 청소함
  2. old : young 청소 시에 살아남은 객체가 복사됨, 청소 작업을 major gc라고 함, young 영역보다 큰 크기로 할당되고 청소 횟수는 적음, 컬렉터마다 다른 방식으로 청소함, 가득 찼을 때 청소
  
* young 영역은 또다시 둘로 나뉨 : Eden과 Supervisor - 처음 생성되면 Eden(에덴 동산에서 따온거인가????)에 저장되고, Eden 가비지컬렉션에서 살아남은 객체는 Supervisor로 이동됨, Supervisor는 두 공간이고 한 공간이 꽉차면 가비지컬렉터 동작(한 영역씩만 사용)
  
* old : 위의 과정에서 살아남은 객체가 옮겨지게 되는 영역
  
### 가비지 컬렉터 종류
1. Serial : young, old gc 시 모두 stop, 싱글쓰레드(처리가 느림 - 서버 환경에서 적합하지않음), 힙 영역을 처음부터 훑으면서 살아있는 것을 확인, 그리고 날림, 앞부분부터 다시 채워서(정리, Compaction) 파편화를 막음
2. Parallel : Serial과 동일하게 young, old 모두 stop 되지만 멀티쓰레드로 처리하는 것이 다름
3. CMS : old에서 stop 시간이 길어지는 것을 보완하기위한 컬렉터, 백그라운드 gc 쓰레드를 둬서 주기적으로 사용되지않는(참조되지않는 객체) old 영역 객체를 청소함, 단점은 백그라운드를 돌리기때문에 소모되는 컴퓨팅 파워와 백그라운드 쓰레드는 앞부분부터 채우도록 하는 정렬 기능이 없어 메모리 파편화가 된다는 단점이 있음, 단점을 채우기위해 Serial처럼 싱글쓰레드로 정리 작업까지도 함(매번은 아니지만 해당 동작이 진행될 때 all stop 됨)
  
4. G1(Garbage First) : ???? 바둑판처럼 메모리를 놔눠두고 메모리 파편화를 막는 것인데 조금 더 알아봐야할듯....
    
### GC 모니터링 프로그램
* CLI : jstat
  * 예제 프로그램 작성 : 입력값(자연수)을 받아 그 만큼 객체를 생성하고, 임의적으로 null 처리한다음 gc가 도는지 체크함
  * jstat 컬럼 : EU(young의 eden 현재 사용 용량을 표시 - 늘어나는 구간은 객체를 생성한 구간, 객체가 생성되고 있는 구간), YGCT(young 영역 가비지컬렉션 누적 시간, EU 용량이 줄어들 때마다 YGCT 타임은 늘어남), GCT(가비지컬렉션 누적 시간)
  * 실험해본 결과 : young 영역부분에 대한 gc가 발생, 객체 생성 시 Eden 영역의 사용량이 늘어나는 것을 볼 수 있음
  * 메모리는 할당용량과 사용용량으로 나눠 생각해야함
  
~~~
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
 0.0    0.0    0.0    0.0   15360.0   1024.0   115712.0     0.0     4480.0 1118.8 384.0   82.4       0    0.000   0      0.000    0.000
 0.0   1024.0  0.0   1024.0 80896.0   7168.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       2    0.003   0      0.000    0.003
 0.0   1024.0  0.0   1024.0 80896.0  36864.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       2    0.003   0      0.000    0.003
 0.0   1024.0  0.0   1024.0 80896.0  65536.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       2    0.003   0      0.000    0.003
 0.0   1024.0  0.0   1024.0 80896.0   4096.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       3    0.005   0      0.000    0.005
 0.0   1024.0  0.0   1024.0 80896.0  31744.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       3    0.005   0      0.000    0.005
 0.0   1024.0  0.0   1024.0 80896.0  60416.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       3    0.005   0      0.000    0.005
 0.0   1024.0  0.0   1024.0 80896.0  13312.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       4    0.007   0      0.000    0.007
 0.0   1024.0  0.0   1024.0 80896.0  41984.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       4    0.007   0      0.000    0.007
 0.0   1024.0  0.0   1024.0 80896.0  70656.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       4    0.007   0      0.000    0.007
 0.0   1024.0  0.0   1024.0 80896.0  16384.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       5    0.008   0      0.000    0.008
 0.0   1024.0  0.0   1024.0 80896.0  43008.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       5    0.008   0      0.000    0.008
 0.0   1024.0  0.0   1024.0 80896.0  58368.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       5    0.008   0      0.000    0.008
 0.0   1024.0  0.0   1024.0 80896.0   2048.0   49152.0      0.0     4864.0 4088.2 512.0  357.0       6    0.009   0      0.000    0.009
 ~~~

* GUI : jconsole

### GC를 어떻게 정할까?
* 많은 컬렉터 중에 모니터링을 해서 적합한 컬렉터를 선정하는 것인가?
  
### 참고자료
* [naver D2 - Java Garbage Collection](https://d2.naver.com/helloworld/1329)
* [naver D2 - Garbage Collection 모니터링 방법](https://d2.naver.com/helloworld/6043)
* [orcle - Java Garbage Collection Basics](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html) - 이미지로 설명해서 더 알기쉬움
* [wiki - HotSpot VM](https://en.wikipedia.org/wiki/HotSpot)
* [okky - 가비지 컬렉터의 배경과 종류](https://okky.kr/article/379036)
  
 