---
title: 'TIL - 0519'
author: imjinbro
date: 2018-05-20 00:31
tags: [TIL, linux, network, spring-boot]
comments: true
sitemap :
  changefreq : daily
  priority : 1.0
---

## 리눅스
### 커널과 배포판의 프리 소프트웨어
* 리눅스는 리눅스 커널(OS 핵심)과 리눅스 배포판을 구성하는 프리 소프트웨어(배포판 사용자들에게 편의 제공을 위한)에 의해 구성됨
* 배포판에는 ubuntu, opensuse, redhat 등이 있음
  
### 터미널 에뮬레이터와 쉘 그리고 쉘프롬프트
* 터미널 (에뮬레이터) : 쉘에 접근할 수 있도록 하는 프로그램 
* 쉘 : 사용자의 명령을 운영체제에 전달(번역)하여 실행될 수 있도록 함
* 쉘프롬프트 : 쉘이 입력가능할 때 나타나는 명령줄
  * 달러($)가 아닌 # 이라면 현재 슈퍼 유저로 쉘을 사용할 수 있는 것
  
~~~
[ubuntu] $
~~~
  
* 터미널 세션 종료 : exit, 창끄기
  
### 파일시스템
* 저장장치를 보다 효율적이게 사용(저장)하고, 빠르게 파일 탐색을 할 수 있도록 도와주는 저장장치에 구현된 시스템(소프트웨어)
  * 마운트 : 파일시스템을 운영체제에서 사용할 수 있도록 연결하는 작업을 마운트라고 함
  * 보통 파일 저장위치 테이블을 만들어두고, 루트디렉토리를 가지고, 파일 저장 블록을 두고 파일을 저장하는 것이 일반적인 파일시스템 : FAT
  * 트리구조로 만들어두고, 탐색할 때 복잡도가 트리 탐색 복잡도 만큼만 걸리도록 설계

* VFS(Virtual File System) : 하나의 리눅스에서 여러 파일시스템을 사용할 수 있는데, 같은 시스템 콜로 파일시스템을 사용할 수 있게 표준(일관성)을 정의해둔 것
  * 공통된 다루는 방법이 있기때문에 여러 파일 시스템을 마운트할 수 있음
  
### 명령어
* date
* cal
* free(memory status)
* pwd(print working directory)
* cd(change directory)
* pstree(linux file system tree)
  
## 네트워크
### IP를 알았다면 통신하자
* 아래 그림은 통신 흐름이다 : 소켓을 만들고 파이프를 생성해서 데이터를 쏟아붓는 것이 데이터 송수신 과정
  
* 데이터 송수신을 하기위해서는 소켓이 있어야함 : 파이프(통로)의 출입구로 생각하면 됨
  * ```소켓 라이브러리의 socket``` : 소켓을 생성하기위해서는 앞서 DNS 서버에 요청보내기위해 리졸버 프로그램을 실행시켰던 것처럼 socket 프로그램을 실행시켜야함
  * 소켓이 생성되면 어플리케이션에는 디스크립터가 돌아옴, **서버는 요청을 받기 전에 먼저 소켓을 만들어두고 클라이언트의 요청이 올 때까지 대기하고 있음**
  * ```디스크립터``` : 하나의 컴퓨터는 여러 데이터 송수신 작업을 할 수 있다, 즉 소켓을 여러개 생성할 수 있다는 것인데 소켓에 대한 정보를 기록이라고 보면 됨, 데이터 송신 요청을 할 때 디스크립터를 넘겨줘서 해당 소켓을 통해서 송신하라고 알려줌
  
* 웹어플리케이션을 포함한 네트워크 작업이 필요한 어플리케이션은 직접 데이터 송수신 작업을 하지못함 : OS에 위임하게되는데, 이떄 사용하는 것이 **프로토콜 스택**임
* 프로토콜 스택도 자체적으로 데이터 송수신을 하는 것이 아니라 소켓 라이브러리를 사용해서 송수신 작업을 함 : 역할 분담을 한 것임
  * ```connect``` : 디스크립터와 IP, 포트를 가지고 상대(서버)의 소켓에 연결하는 작업을 수행함, **IP까지만 있다면 상대의 컴퓨터 위치만 아는 것이고, 포트가 있어야 상대의 소켓에 연결할 수 있음**
  * ```write``` : 디스크립터와 송신하려고 하는 데이터(리퀘스트 메세지, 메모리에 로드)를 가지고, 클라이언트 소켓 - 파이프 - 서버 소켓으로 데이터를 송신하는 작업
  * ```read``` : 서버의 소켓으로부터 데이터를 수신하는 작업을 함, 어플리케이션 **메모리에 수신버퍼를 만들어두고 데이터를 받음**
  * ```close``` : 데이터 송수신 작업을 끝마치면 소켓과 소켓 사이에 연결된 파이프를 해제하고 소켓을 없애버리는 작업, 어느 소켓에서 끊어도 되지만 보통 서버프로그램에서 close()를 함
  
* 자바 코드로 보는 서버프로그램 소켓 생성 - 대기 - 통신 작업 : suedo code급...(흐름 포커스)
  
~~~

public class ConnectorExam {
    public static void main(String[] args) {
    	
    	ServerSocket serverSocket = new ServerSocket(, 80);
    	Socket socket = serverSocket.accept(); // 클라이언트 소켓 연결 대기
    	
    	// 파이프를 통해서 데이터를 수신하고 송신함 - Stream
    	InputStream in = socket.getInputStream();
    	OutputStream out = socket.getOutputStream();
    	
    	int b = in.read();
    	out.write(1);
    	
    	// 통신 끝난 후 close() 작업 - close() 하지않으면 연결이 계속해서 유지된 상태(자원 낭비)
    	in.close();
    	out.close();
    	socket.close();    	
    	serverSocket.close();
    }
}
~~~
  
### IP와 포트
* IP : 네트워크에 연결된 장비에 부여되는 식별번호
* 포트 : **소켓을 식별하는 번호**, 약속되어있는 번호가 있음(웹서버프로그램 : 80, SSH : 22 등)
  * 서버가 클라이언트에 데이터를 송신할 때에도 클라이언트를 식별해야하는 경우가 있음 : 같은 IP(공인)지만 허브에 의해 물려있으므로 내부 IP가 다른 경우, **클라이언트 소켓도 프로토콜 스택에 의해 임의의 포트 번호가 부여됨**. 이에 맞춰서 서버는 데이터 송신 작업을 하면 됨
  * 곧 통신을 하는 프로그램을 식별하는 번호가 됨 : 소켓은 네트워크 프로그램의 요청에 의해 만들어지고, 리턴되는 디스크립터가 소켓을 식별하기때문에 곧 프로그램(요청자)을 식별하는 것 
  
## 스프링
### 스프링빈
* 스프링이 객체를 생성해두고 컨테이너에 담아둠 -> 요청에 따라 라이프 사이클을 관리함 : 생성 - 관리를 위해 빈 등록을 해야하는데, 스프링부트에서는 간단하게 어노테이션만으로 등록가능
  * 빈이 필요하기 전까지는 인스턴스 생성을 미뤄뒀다가 필요할 때 생성함 : lazy-loading

### 자바빈과 스프링빈
* 자바빈 : 데이터를 표현하는 것을 목표로 만든 클래스
* 스프링빈 : 스프링 컨테이너가 사용자 요청에 의해 라이프싸이클, 관계(DI)를 관리하는 오브젝트